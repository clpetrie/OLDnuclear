\documentclass[12pt]{extarticle}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{url}
\usepackage{bm}
\usepackage{color}
\usepackage{fancyvrb}


%My commands
\newcommand{\Oi}{\mathcal{O}_{i}}
\newcommand{\Oij}{\mathcal{O}_{ij}}
\newcommand{\Okl}{\mathcal{O}_{kl}}
\newcommand{\Oijp}{\mathcal{O}^p_{ij}}
\newcommand{\Oklp}{\mathcal{O}^p_{kl}}
\newcommand{\ket}[1]{\left| #1 \right>}
\newcommand{\bra}[1]{\left< #1 \right|}
\newcommand{\braket}[2]{\left< #1 | #2 \right>}
\newcommand{\ketbra}[2]{\left| #1 \right> \left< #2 \right|}
\newcommand{\taui}{\bm{\tau}_i}
\newcommand{\tauj}{\bm{\tau}_j}
\newcommand{\sigmai}{\bm{\sigma}_i}
\newcommand{\sigmaj}{\bm{\sigma}_j}
\newcommand{\tauij}{\taui \cdot \tauj}
\newcommand{\sigmaij}{\sigmai \cdot \sigmaj}
\newcommand{\mycolor}[1]{\textit{\textcolor{red}{#1}}}
\newcommand{\longsi}{s_1, \ldots, s_{i-1} , s, s_{i+1}, \ldots, s_A}
\newcommand{\longsij}{s_1, \ldots, s_{i-1} , s, s_{i+1}, \ldots, s_{j-1}, s', s_{j+1}, \ldots ,s_A}

\newenvironment{blockcode}
  {\leavevmode\small\color{blue}\verbatim}
  {\endverbatim}

\title{Adding independent pair correlations to code}
\author{Cody L. Petrie}

\begin{document}
\maketitle

\section{Independent pair correlations}
Currently the correlated trial wave function looks like
\begin{equation}
  \Psi_T = \bra{R,S} \left[ \prod_{i<j}f_c(r_{ij}) \right] \left[ 1 + \sum_{i<j}\sum_p f_p(r_{ij}) \Oijp \right] \ket{\Phi}.
\end{equation}
The sum term is only the linear term of the correlation. I plan to add the next term. It is called the independent pair correlation term because the it includes the pairs that are summed over in the linear term but each of those is multiplied by a sum over all of the other terms that don't involve particles $i$ or $j$. With the independent pair correlations the correlated trial wave function looks like this.
\begin{equation}
  \Psi_T = \bra{R,S} \left[ \prod_{i<j}f_c(r_{ij}) \right] \left[ 1 + \sum_{i<j}\sum_p f_p(r_{ij}) \Oijp + \sum_p\sum_{i<j}\sum\limits_{\substack{k<l\\k,l \ne i,j}} f_p(r_{ij})\Oijp f_p(r_{ij})\Oklp \right] \ket{\Phi}.
\end{equation}

\subsection{Pseudo code for correlation}
From what I can tell these correlations are primarily handled in the subroutine ``corpsi" in the file ``correlatorcart.f90". I will use the cartesian component version to simplify understanding. The black text represents code that is already in the program, while blue text represents pieces that need to be added to include the independent pair terms.

%,codes={\catcode`$=3\catcode`^=7\catcode`_=8}
\begin{Verbatim}[commandchars=\\\{\}]
ij=0
do i=1,npart-1
   do iop=1,15
      call sxzupdate(sxzi(:,:,:,iop),d15(iop),sxz0,i,sx15(:,iop,:,i),sp(:,i))
\textcolor{red}{This piece does all 15 updates for the ith particle. This is precomputed in an}
\textcolor{red}{outerloop since it will be used repeatedly for the 39 inverse updates for the jth}
\textcolor{red}{particles.}
   enddo
   do j=i+1,npart
      ij=ij+1
      if (doft(ij)) then
         do it=1,2
            fij=ft(ij)
            sx15j(:,:,:)=conjg(opmult(conjg(sxzi(:,j,:,3+it))))
            call sxzupdate(sxzj,d2,sxzi(:,:,:,3+it),j,sx15j(:,3+it,:) &
               ,sp(:,j))
\textcolor{red}{This uses sxzi(:,:,:,4-5) as the old sxz so it's doing the terms txi*txj tyi*tyj.}
            detrat=d15(3+it)*d2
            fij=detrat*fij
            call g1bval(d1b,sxzj,fij)
            call g2bval(d2b,sxzj,fij)
            call g3bval(d3b,sxzj,fij)
         enddo
      endif
      if (doft(ij).or.doftpp(ij).or.doftnn(ij)) then
         it=3
         fij=ft(ij)
         if (doftpp(ij)) fij=fij+0.25_r8*ftpp(ij)
         if (doftnn(ij)) fij=fij+0.25_r8*ftnn(ij)
         sx15j(:,:,:)=conjg(opmult(conjg(sxzi(:,j,:,3+it))))
         call sxzupdate(sxzj,d2,sxzi(:,:,:,3+it),j,sx15j(:,3+it,:),sp(:,j))
\textcolor{red}{This uses sxzi(:,:,:,6) as the old sxz so i'ts doing tzi*tzj. Why is this done}
\textcolor{red}{seperately from tx and ty? I assume it as to do with doftpp and doftnn but I don't}
\textcolor{red}{know what those are.}
         detrat=d15(3+it)*d2
         fij=detrat*fij
         call g1bval(d1b,sxzj,fij)
         call g2bval(d2b,sxzj,fij)
         call g3bval(d3b,sxzj,fij)
      endif
      if (dofs(ij)) then
         do is=1,3
            sx15j(:,:,:)=conjg(opmult(conjg(sxzi(:,j,:,is))))
            do js=1,3
               call sxzupdate(sxzj,d2,sxzi(:,:,:,is),j,sx15j(:,js,:),sp(:,j))
\textcolor{red}{here since the old sxz is sxz(:,:,:,is) where is and js both go from 1 to 3 this}
\textcolor{red}{is doing the sxi*(sxj+syj+szj), syi*(sxj+syj+szj), and szi*(sxj+syj+szj) terms.}
\textcolor{red}{There are 9 total here.}
               detrat=d15(is)*d2
               fij=detrat*fs(is,js,ij)
               call g1bval(d1b,sxzj,fij)
               call g2bval(d2b,sxzj,fij)
               call g3bval(d3b,sxzj,fij)
            enddo
         enddo
      endif
      if (dofst(ij)) then
         do it=1,3
            do is=1,3
               sx15j(:,:,:)=conjg(opmult(conjg(sxzi(:,j,:,3*is+it+3))))
               do js=1,3
                  call sxzupdate(sxzj,d2,sxzi(:,:,:,3*is+it+3),j &
                     ,sx15j(:,3*js+it+3,:),sp(:,j))
                  detrat=d15(3*is+it+3)*d2
                  fij=detrat*fst(is,js,ij)
                  call g1bval(d1b,sxzj,fij)
                  call g2bval(d2b,sxzj,fij)
                  call g3bval(d3b,sxzj,fij)
               enddo
            enddo
         enddo
      endif
   enddo
enddo
\end{Verbatim}

\end{document}
